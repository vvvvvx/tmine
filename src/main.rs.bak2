//--------TMine--------
//Begin time: 2023-04-07
//Author    : Viaco Xu
//--------TMine--------

//use std::io::Write;
use crossterm::{
    cursor,
    cursor::{Hide, Show},
    execute, terminal::{self, SetSize}, QueueableCommand,
};
use crossterm::{
    event::{read, Event, KeyCode, KeyEvent},
    terminal::{disable_raw_mode, enable_raw_mode,size},
};
use rand::Rng;
use std::io::{self};
use std::process::exit;
use std::vec;
//use crossterm::{cursor::{ MoveTo}, style::{Color, Print, ResetColor, SetBackgroundColor}};
use std::io::{stdout, Write};

/* ASCI转移字符
红色：\x1B[31m
绿色：\x1B[32m
黄色：\x1B[33m
蓝色：\x1B[34m
洋红色：\x1B[35m
青色：\x1B[36m
重置：\x1B[0m
*/

#[derive(Clone)]
struct Level {
    rows: i16, //rows
    cols: i16, //columns
    mines: i16,
    width: u16,  //screen width needed
    height: u16, //screen height needed
}
impl Level {
    pub fn new() -> Level {
        let l = select_level();
        match l {
            1 => Level {
                rows: 8,
                cols: 10,
                mines: 7,
                width: 10 * 4 + 3 + 20,
                height: 8 * 2 + 4,
            },
            2 => Level {
                rows: 9,
                cols: 14,
                mines: 15,
                width: 14 * 4 + 3 + 20,
                height: 9 * 2 + 4,
            },
            3 => Level {
                rows: 15,
                cols: 20,
                mines: 40,
                width: 20 * 4 + 3 + 20,
                height: 15 * 2 + 4,
            },
            4 => Level {
                rows: 19,
                cols: 26,
                mines: 99,
                width: 26 * 4 + 3 + 20,
                height: 19 * 2 + 4,
            },
            _ => Level {
                rows: 8,
                cols: 10,
                mines: 7,
                width: 10 * 4 + 3 + 20,
                height: 8 * 2 + 4,
            },
        }
    }
    //选择难度级别
}

#[derive(Clone, PartialEq)]
enum Status {
    Opened,     //已开/have opened
    Flaged,     //已标记雷/Flaged mine
    Unexplored, //未探明
    Pending,    //未决
}

#[derive(Clone)]
struct Cell {
    is_mine: bool,    //是否有雷
    surrnd_mines: i8, //周围雷数
    status: Status,   //单元格状态
}
impl Cell {
    pub fn new() -> Cell {
        Cell {
            is_mine: false,
            surrnd_mines: 0,
            status: Status::Unexplored,
        }
    }
    pub fn set_mine(&mut self, b: bool) {
        self.is_mine = b;
    }
    pub fn set_surrnd(&mut self, n: i8) {
        self.surrnd_mines = n;
    }
    pub fn set_status(&mut self, s: Status) {
        self.status = s;
    }
    pub fn reset(&mut self) {
        self.is_mine = false;
        self.surrnd_mines = 0;
        self.status = Status::Unexplored;
    }
}
//#[derive(Clone)]
pub struct Game {
    level: Level,
    mine_table: Vec<Vec<Cell>>,
    time_consuming: i16,
    mines_left: i16,
}

impl Game {
    pub fn new() -> Game {
        //level==1 新手
        //level==2 初级
        //level==3 中级
        //level==4 高级
        let lv = Level::new();

        Game {
            level: lv.clone(),
            mine_table: (vec![vec![Cell::new(); lv.cols as usize]; lv.rows as usize]),
            time_consuming: (0),
            mines_left: (lv.mines),
        }
    }
    //随机初始化雷阵
    fn laying_mine(&mut self) {
        //各单元格复位
        for i in 0..self.mine_table.len() {
            for j in 0..self.mine_table[i].len() {
                self.mine_table[i][j].reset();
            }
        }
        let mut i = self.level.mines;
        while i > 0 {
            //生成地雷随机坐标
            let x = get_rand(self.level.cols);
            let y = get_rand(self.level.rows);
            //布雷
            if self.mine_table[y as usize][x as usize].is_mine == false {
                self.mine_table[y as usize][x as usize].is_mine = true;
                i -= 1;
            }
        }
    }

    fn display_refresh(&mut self) {
        //let  stdout = io::stdout();

        for i in 0..self.mine_table.len() {
            for j in 0..self.mine_table[i].len() {
                refresh_cell(&j, &i, &mut self.mine_table[i][j])
                // let (x,y)=locate(j as u16, i as u16);
                // stdout.queue(cursor::MoveTo(x,y));
                // let  c=&self.mine_table[i][j];

                // match c.status {
                //     Status::Opened=>{
                //         if !c.is_mine { //如果不是雷
                //            if c.surrnd_mines==0{//如果周围没有雷，显示绿色O，
                //                 print!("\x1B[32mO\x1B[0m")
                //             }
                //             if c.surrnd_mines>0{//如果周围有雷，显示绿色数字
                //                 print!("\x1B[32m{}\x1B[0m",c.surrnd_mines)
                //             }
                //         }else{ //如果是雷，显示红色“M”
                //             print!("\x1B[31mM\x1B[0m")
                //         }
                //     },
                //     Status::Flaged=>{//如果已经标记为雷，显示蓝色F
                //         print!("\x1B[34mF\x1B[0m")
                //     },
                //     Status::Pending=>{ //如果存疑，显示蓝色问号
                //         print!("\x1B[34m?\x1B[0m")
                //     },
                //     Status::Unexplored=>{

                //     },
                //     _=>{ }
                // }
                /*
                if self.mine_table[i][j].is_mine==true{
                    let mut stdout = io::stdout();
                    let (x,y)=locate(j as u16, i as u16);
                    stdout.queue(cursor::MoveTo(x,y));
                    print!("\x1B[31mM\x1B[0m");
                    stdout.flush();
                }else{
                     let mut stdout = io::stdout();
                    let (x,y)=locate(j as u16, i as u16);
                        stdout.queue(cursor::MoveTo(x,y));
                    print!("{}",self.mine_table[i][j].surrnd_mines);
                    stdout.flush();

                }
                */
            }
        }

        //stdout.flush();
    }

    fn display_mine(&mut self) {
        for i in 0..self.mine_table.len() {
            for j in 0..self.mine_table[i].len() {
                //refresh_cell(&j, &i, &mut self.mine_table[i][j])
                if self.mine_table[i][j].status == Status::Opened
                    || (self.mine_table[i][j].status == Status::Flaged
                        && self.mine_table[i][j].is_mine)
                {
                    //如果已经打开了，则不管。

                    continue;
                }
                if self.mine_table[i][j].is_mine == true {
                    let mut stdout = io::stdout();
                    let (x, y) = locate(j as u16, i as u16);
                    stdout.queue(cursor::MoveTo(x, y)).unwrap();
                    print!("\x1B[31mM\x1B[0m");
                    stdout.flush().unwrap();
                }
            }
        }
    }
    //计算余雷统计信息打印位置
    fn get_stat_mine_pos(&self) -> (u16, u16) {
        return ((4 * self.level.cols + 6) as u16, 2);
    }
    //计算耗时显示信息打印位置
    fn get_stat_time_pos(&self) -> (u16, u16) {
        return ((4 * self.level.cols + 6) as u16, 3);
    }
    //计算帮助信息打印位置
    fn get_help_pos(&self) -> (u16, u16) {
        return ((4 * self.level.cols + 6) as u16, 5);
    }
    //计算命令提示信息打印位置
    fn get_cmd_pos(&self) -> (u16, u16) {
        return ( (4 * self.level.cols + 6) as u16,((self.level.rows + 1) * 2) as u16, );
    }
    fn get_table_mid_pos(&self)->(u16,u16){
        return ( ((4 * self.level.cols+3)/2) as u16,(self.level.rows) as u16);
    }
    //计算周围雷数
    fn calc_surrnd_mines(&mut self) {
        for i in 0..self.mine_table.len() {
            for j in 0..self.mine_table[i].len() {
                if self.mine_table[i][j].is_mine == false {
                    self.mine_table[i][j].surrnd_mines = calc_mines(&j, &i, &self.mine_table);
                }
            }
        }
    }
    //失败，画面爆炸
    fn explode(&mut self) {
        self.display_mine();
        let (x,y)=self.get_table_mid_pos();
        let mut stdout = io::stdout();
        stdout.queue(cursor::MoveTo(x -4, y)).unwrap();
        print!("\n\x1B[31m\x1B[5m\x1B[1m您失败了！\n\x1B[0m");

        stdout.flush().unwrap();
    }

    //更新余雷数量
    fn refresh_mine_left(&self) {
        let (x, y) = self.get_stat_mine_pos();
        let mut stdout = io::stdout();
        stdout.queue(cursor::MoveTo(x + 6, y-2)).unwrap();
        print!("{} ", self.mines_left);
        stdout.flush().unwrap();
    }
    fn check_all_flaged(&self)->bool{
        for i in 0..self.mine_table.len() {
            for j in 0..self.mine_table[i].len() {
                if self.mine_table[i][j].status == Status::Unexplored {
                    return false;
                }
            }
        }
        return true;
    }
    fn check_flag_correct(&self)->bool{
        for i in 0..self.mine_table.len() {
            for j in 0..self.mine_table[i].len() {
                if self.mine_table[i][j].status == Status::Flaged && self.mine_table[i][j].is_mine==false {
                    return false;
                }
            }
        }
        return true;
    }
    fn success_check(&self){
        //地雷数==0
        //无未探明的雷

        //无错误的雷

        //打印胜利信息

        //显示所用时间

    }
    //翻开单元格
    //x、y为mine_arr数组index坐标
    fn dig_cell(&mut self, x: &usize, y: &usize, cmd: &char) {
        //let  m: &mut Cell=&mut (self.mine_table[*y][*x]);
        match self.mine_table[*y][*x].status {
            //根据
            Status::Unexplored => {
                match cmd {
                    'F' => {
                        self.mine_table[*y][*x].status = Status::Flaged;
                        self.mines_left -= 1; //剩余雷减1
                        refresh_cell(x, y, &self.mine_table[*y][*x]);
                        self.refresh_mine_left(); //更新余雷数量显示
                    }
                    'P' => {
                        self.mine_table[*y][*x].status = Status::Pending;
                        refresh_cell(x, y, &self.mine_table[*y][*x]);
                    }
                    'D' | ' ' | '\n' => {
                        //D、Space、Enter
                        self.mine_table[*y][*x].status = Status::Opened; //修改会未开
                                                                         //修改单元格界面
                        refresh_cell(x, y, &self.mine_table[*y][*x]);
                        if self.mine_table[*y][*x].is_mine {
                            self.explode(); //触发爆炸，程序结束
                            return;
                        }
                        if self.mine_table[*y][*x].surrnd_mines == 0 {
                            //递归翻开周围单元格
                            //限定数组边界
                            let tx = *x as i16 - 1;
                            let ty = *y as i16 - 1;
                            let min_x = if tx < 0 { &0 } else { &tx };
                            let min_y = if ty < 0 { &0 } else { &ty };

                            let mx = *x + 2;
                            let my = *y + 2;

                            let tmax_x = &self.mine_table[0].len();
                            let tmax_y = &self.mine_table.len();
                            let max_x = if mx > *tmax_x { tmax_x } else { &mx };
                            let max_y = if my > *tmax_y { tmax_y } else { &my };
                            for yy in *min_y as usize..*max_y {
                                for xx in *min_x as usize..*max_x {
                                    if self.mine_table[yy as usize][xx as usize].status
                                        == Status::Unexplored
                                        && !(xx == *x && yy == *y)
                                    {
                                        self.dig_cell(&(xx as usize), &(yy as usize), &'D');
                                    }
                                }
                            }
                        }
                    }
                    _ => {} //Test Openator 'T' can't use in this case
                }
            } //Status Unexplored
            Status::Opened => {
                match cmd {
                    'T' | '\n' | ' ' => {
                        //Test:如果测试周围Flag数量==srrnd_mines,则把周围未开的的全开
                        let tx = *x as i16 - 1;
                        let ty = *y as i16 - 1;
                        let min_x = if tx < 0 { &0 } else { &tx };
                        let min_y = if ty < 0 { &0 } else { &ty };

                        let mx = *x + 2;
                        let my = *y + 2;

                        let tmax_x = &(self.level.cols as usize);
                        let tmax_y = &(self.level.rows as usize);
                        let max_x = if mx > *tmax_x { tmax_x } else { &mx };
                        let max_y = if my > *tmax_y { tmax_y } else { &my };
                        let mut sum_mines = 0;
                        //计算周围标记的雷个数
                        for yy in *min_y as usize..*max_y {
                            for xx in *min_x as usize..*max_x {
                                if self.mine_table[yy as usize][xx as usize].status
                                    == Status::Flaged
                                {
                                    sum_mines += 1;
                                }
                            }
                        }
                        //如果标记的数量等于单元格总雷数，则把除标记之外的单元格都打开
                        if self.mine_table[*y][*x].surrnd_mines == sum_mines {
                            for yy in *min_y as usize..*max_y {
                                for xx in *min_x as usize..*max_x {
                                    if self.mine_table[yy as usize][xx as usize].status
                                        != Status::Flaged
                                        && !(xx == *x && yy == *y)
                                    {
                                        if self.mine_table[yy as usize][xx as usize].surrnd_mines
                                            > 0
                                        {
                                            self.mine_table[yy as usize][xx as usize].status =
                                                Status::Opened;
                                            refresh_cell(&xx, &yy, &self.mine_table[yy][xx]);
                                        } else {
                                            //如果打开的单元格雷数为0,则递归展开
                                            self.dig_cell(&xx, &yy, &'D');
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            Status::Flaged => {
                //已经标记的，则取消标记
                match cmd {
                    'D' => {
                        //强制撬开
                        self.mine_table[*y][*x].status = Status::Unexplored;
                        self.dig_cell(x, y, &'D');
                    }
                    'F' => {
                        //取消标记
                        self.mine_table[*y][*x].status = Status::Unexplored;
                        refresh_cell(x, y, &self.mine_table[*y][*x]);
                    }
                    'P' => {
                        //重新标记为Pending
                        self.mine_table[*y][*x].status = Status::Pending;
                        refresh_cell(x, y, &self.mine_table[*y][*x]);
                    }
                    _ => {}
                }
                //self.display_refresh();
                //refresh_cell(x, y, &self.mine_table[*y][*x]);
            }
            Status::Pending => {
                match cmd {
                    'D' | '\n' | ' ' => {
                        //打开
                        self.mine_table[*y][*x].status = Status::Unexplored;
                        self.dig_cell(x, y, &'D');
                    }
                    'F' => {
                        //标记
                        self.mine_table[*y][*x].status = Status::Flaged;
                        refresh_cell(x, y, &self.mine_table[*y][*x]);
                    }
                    _ => {}
                }
            }
            //_=>{}
        }
    }

    fn pause(&self) {
        let mut stdout = io::stdout();
		for i in 0..self.mine_table.len() {
            for j in 0..self.mine_table[i].len() {
				let (x, y) = locate(j as u16, i as u16);
				stdout.queue(cursor::MoveTo(x-1, y)).unwrap();
				print!("   ");
				stdout.flush().unwrap();
            }
            
        }
	}

	fn restore(&mut self){
		self.display_refresh();
	}
    //绘制界面
    fn draw_table(&self) -> Result<(), std::io::Error> {
        let row = self.level.rows;
        let col = self.level.cols;
        // 获取标准输出流
        let mut stdout = io::stdout();

        // 清屏
        stdout.queue(terminal::Clear(terminal::ClearType::All))?;
        stdout.queue(cursor::MoveTo(0, 0))?;
        //打印标题信息
        //stdout.write_all("  剩余雷：       所用时间：       \n".as_bytes())?;
        //打印列序号
        print!("   {}", (65) as char);
        for i in 0..col - 1 {
            let c = 66 + i;
            print!("   {}", (c as u8) as char);
        }
        print!("\n");
        //打印表格第一行
        let mut first_line: String = String::from(" ┌");
        for _i in 0..col - 1 {
            first_line += "───┬";
        }
        first_line += "───┐\n";
        stdout.write_all(first_line.as_bytes())?;
        //打印表格中间行
        //拼接中间行字符串
        let mut mid_line: String = String::from(" ├");
        for _i in 0..col - 1 {
            mid_line += "───┼";
        }
        mid_line += "───┤\n";

        //拼接衔接列
        let mut jj_line: String = String::from("│");
        for _i in 0..col + 0 {
            jj_line += "   │"
        }
        //打印中间行
        for i in 0..row - 1 {
            //jj_line+="\n";
            let c = 65 + i;
            print!("{}", (c as u8) as char); //打印左侧行序号
            stdout.write_all(jj_line.as_bytes())?;
            print!("{}\n", (c as u8) as char); //打印右侧行序号
            stdout.write_all(mid_line.as_bytes())?;
        }
        //打印底行
        let mut bot_line: String = String::from(" └");
        for _i in 0..col - 1 {
            bot_line += "───┴";
        }
        bot_line += "───┘\n";
        let c = 65 + row - 1;
        print!("{}", (c as u8) as char); //打印最后一行左侧行序号
        stdout.write_all(jj_line.as_bytes())?;
        print!("{}\n", (c as u8) as char); //打印最后一行右侧行序号
        stdout.write_all(bot_line.as_bytes())?;
        //打印底边列号
        print!("   {}", (65) as char);
        for i in 0..col - 1 {
            let c = 66 + i;
            print!("   {}", (c as u8) as char);
        }
        print!("\n");

        //打印提示信息
        let (x, y) = self.get_stat_mine_pos();
        stdout.queue(cursor::MoveTo(x, y - 1))?;
        print!("─────统计─────");
        stdout.queue(cursor::MoveTo(x, y))?;
        print!("余雷：{}", self.level.mines);
        let (x1, y1) = self.get_stat_time_pos();
        stdout.queue(cursor::MoveTo(x1, y1))?;
        print!("耗时：");
        let (x2, y2) = self.get_cmd_pos();
        stdout.queue(cursor::MoveTo(x2, y2 - 1))?;
        print!("─────命令─────");
        stdout.queue(cursor::MoveTo(x2, y2))?;
        print!("Input：");
        // 打印帮助信息
        let (x3, y3) = self.get_help_pos();
        stdout.queue(cursor::MoveTo(x3, y3))?;
        print!("─────帮助─────");
        stdout.queue(cursor::MoveTo(x3, y3 + 1))?;
        print!("命令:行+列+命令");
        stdout.queue(cursor::MoveTo(x3, y3 + 2))?;
        print!("F-Flag    标记");
        stdout.queue(cursor::MoveTo(x3, y3 + 3))?;
        print!("D-Dig     翻开");
        stdout.queue(cursor::MoveTo(x3, y3 + 4))?;
        print!("T-Test    测试");
        stdout.queue(cursor::MoveTo(x3, y3 + 5))?;
        print!("P-Pending 疑问");
        stdout.queue(cursor::MoveTo(x3, y3 + 7))?;
        print!("!Q-Quit   退出");
        stdout.queue(cursor::MoveTo(x3, y3 + 8))?;
        print!("!P-Pause  暂停");
        stdout.queue(cursor::MoveTo(x3, y3 + 9))?;
        print!("!R-Restore恢复");
        stdout.queue(cursor::MoveTo(x3, y3 + 10))?;
        print!("!N-New    重玩");
        return stdout.flush();
    }
}

fn new_game() -> Game {
    clear_screen();

    disable_raw_mode().expect("Failed to enable raw mode");
    let mut game = Game::new();

    // 获取窗口大小
    // let (width, height) = match terminal::size() {
    //     Ok((w, h)) => (w, h),
    //     Err(e) => {
    //         println!("Get terminal size error: {:?}", e);
    //         (0, 0)
    //     }
    // };

    //调整窗口大小
    print!("\x1B[8;{};{}t", game.level.height, game.level.width);
    stdout().flush().unwrap();

    game.laying_mine();
    game.draw_table().unwrap();
    game.calc_surrnd_mines();
    enable_raw_mode().expect("Failed to enable raw mode");
    return game;
}
fn main() -> io::Result<()> {
    // let mut game=Game::new();

    // game.laying_mine();
    // game.draw_table()?;
    // game.calc_surrnd_mines();
    let mut game = new_game();
    let mut stdout = stdout();
    let mut cmd: String = String::new();
    let (mut x, mut y) = game.get_cmd_pos();
    let mut c_count: i8 = 0;
    //隐藏光标
    execute!(std::io::stdout(), Hide).unwrap();
    //开启raw mode,监听键盘输入
    enable_raw_mode().expect("Failed to enable raw mode");
    loop {
        stdout.queue(cursor::MoveTo(x + 7, y)).unwrap();

        match read().expect("Failed to read event") {
            Event::Key(KeyEvent { code: KeyCode::Char(c), .. }) => {
                c_count += 1;
                cmd += c.to_ascii_uppercase().to_string().as_str();
                print!("{} ", cmd);
                stdout.flush().expect("Failed to flush output");
            }
            Event::Key(KeyEvent { code: KeyCode::Enter, .. }) => {
                stdout.flush().expect("Failed to flush output");
                if cmd == "!EXIT" || cmd == "!Q" || cmd == "!QUIT" {
                    break;
                }
                if c_count >= 2 {
                    //如果命令长度已满足
                    let c_y = cmd.chars().nth(0).unwrap(); //Y坐标字母
                    let c_x = cmd.chars().nth(1).unwrap(); //X坐标字母

                    let mut c_cmd = ' ';
                    if c_count >= 3 {
                        c_cmd = cmd.chars().nth(2).unwrap(); //命令字符
                    }
                    if c_y != '!' && c_x as u8 >= 65 && c_y as u8 >= 65 {
                        //确保输入的是A以上的字母
                        let x = c_x as usize - 65;
                        let y = c_y as usize - 65;
                        if x < game.level.cols as usize && y < game.level.rows as usize {
                            //确保未超最大行列

                            // print!("\x1B[32;1m\x1B[40 {} \x1B[0m",3);
                            game.dig_cell(&x, &y, &c_cmd); //挖开此单元格
                        }
                    }
                    if c_y == '!' {
                        match c_x {
                            'Q' => {
                                //退出程序 Exit program

                                execute!(std::io::stdout(), Show).unwrap();
                                disable_raw_mode().expect("Failed to enable raw mode");
                                exit(0);
                            }
                            'P' => { //暂停游戏 Pause
								game.pause();
                            }
                            'R' => { //继续游戏 Restore
								game.restore();
					        }
                            'N' => {
                                //新开游戏 New game
                                game = new_game();
                                (x, y) = game.get_cmd_pos();
                                cmd.clear();
                                c_count = 0;
                            }
                            _ => {}
                        }
                    }
                }
                c_count = 0;
                cmd.clear();
            }
            Event::Key(KeyEvent { code: KeyCode::Backspace, .. }) => {
                //print!("\u{8}");//退格
                cmd.pop(); //删除最后一个字符
                print!("{} ", cmd);
                c_count -= 1;
                stdout.flush().expect("Failed to flush output");
            }
            Event::Key(KeyEvent { code: KeyCode::Esc, .. }) => {
                disable_raw_mode().expect("Failed to disable raw mode");
                cmd.clear();
                c_count = 0;
            }
            _ => (),
        }
    }
    //显示光标
    execute!(std::io::stdout(), Show).unwrap();
    //关闭raw mode
    disable_raw_mode().expect("Failed to enable raw mode");
    //game.display_mine();
    //    draw_table(&level.rows, &level.cols)?;
    clear_screen();
    Ok(())
}

/*
fn reverse_display_row(row:&u8,level:&Level){
    let r=row-65;//根据字母ASC码计算行号
    let (_,y)=locate(0, r as u16);//定位行位置

    let mut stdout = stdout();
    execute!(stdout, MoveTo(1, y)).unwrap();
    // 获取当前光标位置
    //let (x, y) = position().unwrap();
    // 将光标移动到光标所在位置
    //execute!(stdout, MoveTo(x, y)).unwrap();
    // 获取屏幕上该位置的字符

    let mut buffer: [u8; 1] = [0; 1];
   // let _ = stdout.read(&mut buffer);
    // let _ = (&mut stdout).read(&mut buffer);
    // let mut stdout = stdout.into_raw_mode().unwrap(); // 转换为原始模式
    // 获取屏幕上该位置的字符
    let mut buffer: [u8; 1] = [0; 1];
    //let _ = (&mut stdout).read(&mut buffer);
    let c = std::char::from_u32(buffer[0] as u32).unwrap();
    let c = std::char::from_u32(buffer[0] as u32).unwrap();
    // 反转颜色并打印字符
    execute!(stdout, SetBackgroundColor(Color::Black), Print(c), ResetColor).unwrap();
}
*/
/* ASCI转移字符
红色：\x1B[31m
绿色：\x1B[32m
黄色：\x1B[33m
蓝色：\x1B[34m
洋红色：\x1B[35m
青色：\x1B[36m
92淡绿色

背景：

    40：黑色
    41：红色
    42：绿色
    43：黄色
    44：蓝色
    45：洋红色
    46：青色
    47：白色

绿色背景：\x1b[42m
重置：\x1B[0m
*/

//清屏
fn clear_screen() {
    // 获取标准输出流
    let mut stdout = io::stdout();

    // 清屏
    stdout
        .queue(terminal::Clear(terminal::ClearType::All))
        .unwrap();
    stdout.queue(cursor::MoveTo(0, 0)).unwrap();
}
//刷新单元格内容
fn refresh_cell(x: &usize, y: &usize, cell: &Cell) {
    let mut stdout = io::stdout();
    let (x1, y1) = locate(*x as u16, *y as u16);
    stdout.queue(cursor::MoveTo(x1 - 1, y1)).unwrap();
    //cursor::Hide;
    let c = cell;
    match c.status {
        Status::Opened => {
            if !c.is_mine {
                //如果不是雷
                if c.surrnd_mines == 0 {
                    //如果周围没有雷，显示淡绿色背景，
                    print!("\x1B[90m\x1B[100m   \x1B[0m");
                }
                if c.surrnd_mines > 0 {
                    //如果周围有雷，显示绿色数字
                    print!("\x1B[32;1m\x1B[100m {} \x1B[0m", c.surrnd_mines);
                }
            } else {
                //如果是雷，显示红色“M”，黄色背景
                print!("\x1B[31m\x1B[43m M \x1B[0m");
            }
        }
        Status::Flaged => {
            //如果已经标记为雷，显示红色F
            print!("\x1B[31m\x1B[100m F \x1B[0m");
        }
        Status::Pending => {
            //如果存疑，显示蓝色问号
            print!("\x1B[34m\x1B[100m ? \x1B[0m");
        }
        Status::Unexplored => {
            print!("   ");
            /*  if !c.is_mine { //如果不是雷
                    if c.surrnd_mines==0{//如果周围没有雷，显示绿色背景，
                         print!("\x1B[100m   \x1B[0m");
                     }
                     if c.surrnd_mines>0{//如果周围有雷，显示绿色数字
                         print!("\x1B[32;1m\x1B[100m {} \x1B[0m",c.surrnd_mines);
                     }
                 }else{ //如果是雷，显示红色“M”
                     print!("\x1B[31m M \x1B[0m");
                 }
            */
        }
        //_=>{ }
    }
    stdout.flush().unwrap();
}
//计算坐标（x,y）单元格周围的雷数
fn calc_mines(x: &usize, y: &usize, mine_arr: &Vec<Vec<Cell>>) -> i8 {
    let max_x = mine_arr[0].len();
    let max_y = mine_arr.len();

    let min_x: usize = if *x == 0 { 0 } else { x - 1 };
    let min_y: usize = if *y == 0 { 0 } else { y - 1 };

    let mut sum: i8 = 0;
    for i in min_y..y + 2 {
        for j in min_x..x + 2 {
            if !(i == *y && j == *x) && i < max_y && j < max_x && mine_arr[i][j].is_mine == true {
                sum += 1;
            }
        }
    }
    return sum;
}

//产生随机数
fn get_rand(range: i16) -> i16 {
    let mut rng = rand::thread_rng();
    return rng.gen_range(0, range);
}
//处理数字输入
fn input() -> i16 {
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    let num: i16 = match input.trim().parse::<i16>() {
        Ok(n) => n,
        Err(_) => {
            println!("\x1B[31m\x1B[1m输入错误，请输入数字。\x1B[0m");
            return -1;
        }
    };
    return num;
}

fn select_level() -> i16 {
    print!("\n请选择难度级别：\n   1--新手  8x10  [  7 Mines ]\n   2--初级  9x14  [ 15 Mines ]\n   3--中级 15x20  [ 40 Mines ]\n   4--高级 19x26  [ 99 Mines ]\n   0--退出程序\n\n请选择：");

    if io::stdout().flush().is_err() {
        println!("flush err");
    };
    let mut num = input();
    while num < 0 || num > 4 {
        if num > 4 {
            println!("请输入0-4以内的数，以确定难度级别");
        }
        num = input();
    }
    if num == 0 {
        exit(0)
    }
    return num;
}

//根据行列定位表格坐标，提供给cursor::MoveTo()使用
pub fn locate(col: u16, row: u16) -> (u16, u16) {
    return ((3 + 4 * col), (2 + row * 2));
}
